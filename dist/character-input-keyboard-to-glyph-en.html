<html>
<head>
    <title>A character's journey from finger to glyph</title>
    <link rel="stylesheet" type="text/css" href="/css/style.css" />
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      processEscapes: true,
      menuSettings: { inTabOrder: false },
      "AssistiveMML": {
         disabled: false,
         styles: {
            ".MJX_Assistive_MathML": {
                position:"absolute!important",
                clip: (MathJax.Hub.Browser.isMSIE && (document.documentMode||0) < 8 ?
                    "rect(1px 1px 1px 1px)" : "rect(1px, 1px, 1px, 1px)"),
                padding: "1px 0 0 0!important",
                border: "0!important",
                height: "1px!important",
                width: "1px!important",
                overflow: "hidden!important",
                display:"block!important"
            }
        }
      }
    });
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, type=text/html" charset="UTF-8">
    <link rel="stylesheet" href="/css/style.css">
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
    <!-- Cloudflare Web Analytics -->
    <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "5b8562dcfaa5413ba2aea8294b9d585e"}'></script><!-- End Cloudflare Web Analytics -->
</head>
<body>
    <h2>A character's journey from finger to glyph</h2>

<p>For the past several months I've been a little bit obsessed with understanding how <em>exactly</em> character input works on my computer. When I press a key on my keyboard, where does that data go? Which processes on my OS see the value of my keypress? What are the different software representations of a keypress?</p>

<p>I've finally reached the point where I'm comfortable enough  with this topic to write about it. Because my personal computer is a Macbook and I spend a lot of time coding from the command line, the OS- and application-specific details are centered on MacOS (currently Sonoma 14.2) and the <code>Terminal</code> application, but many of the tidbits here are broadly applicable. Figuring out how this compares to Windows and Linux in-depth would be a fun digression but I've chosen not to go down that rabbit hole here - maybe in  another post! Regardless, much of what I've written here is somewhat applicable to Linux (especially the TTY stuff).</p>

<p>I feel that one could seriously write a novel on this topic, so I've tried to at least keep this blog post from <em>appearing</em> intimidatingly bloated by hiding some of the details behind accordion dropdowns. My understanding of some parts is woefully incomplete, so I may return to this post with edits as I keep digging.</p>

<hr>

<p>Here's a diagram I made summarizing all of the steps in this journey:</p>

<p><center>
<img src="/img/2024-11-30-Fig1.png" alt="Fig 1" />
</center></p>

<p>Here we go!</p>

<hr>

<p><strong>(Keypress to scancode.)</strong> Physical keyboards typically don't know anything about character codes (ASCII, Unicode, whatever). Instead, they map keys to numbers called <a href="https://en.wikipedia.org/wiki/Scancode">scan codes</a> that are based on the row and column of each key on the physical keyboard. This includes both the keys corresponding to characters and the modifier keys like Shift, Control, etc. </p>

<p>There are several different possible <a href="https://en.wikipedia.org/wiki/Keyboard_layout">physical keyboard layouts</a> that determine how keypresses are mapped to scancodes.</p>

<p><details>
<summary>Tell me more about how a Macbook uses its built-in keyboard or an external USB keyboard</summary></p>

<blockquote>
<p>A keyboard (or any kind of peripheral) must use some kind of <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> to communicate with a computer. There are several existing standards for bus communication, among which are the <a href="https://en.wikipedia.org/wiki/USB">USB standards</a>.</p>
<p>On MacOS, you can view information about hardware peripherals by opening <code>System Preferences &gt; General &gt; System Information</code>. In this menu, I was able to see metadata about a USB keyboard that I had connected to my Macbook. I was also able to find out that the built-in keyboard and trackpad use a different standard called <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">Serial Peripheral Interface</a>.</p>
<p>We have to make a distinction here between a <em>device controller</em> and a <em>device driver</em> for computer peripherals. The former is a piece of hardware, and the latter is a piece of software. The device controller and driver depend on the bus protocol used by the peripheral, whether it be USB or SPI or something else (e.g. the legacy standard PS/2), and decodes electronic signals from the peripheral into bytes. The device driver makes these bytes available to the OS by providing a software interface for interpreting and retrieving them.</p>
<p>USB keyboards are typically "passive" in the sense that they do not have their own power source, relying on the controller to generate a current for communication (and a clock signal for synchonization). Individual bits are transmitted using differential voltage across wires joining the keyboard and keyboard controller. You can actually see the exact current requirements of a USB keyboard from <code>System Information</code>.</p>
<p>The exact mechanics of this software interface on MacOS are still unclear to me. As far as I can tell from reading the <code>IOKit</code> docs: the hardware controller polls the keyboard for keypress information and generates interrupts through the hardware driver when there is keypress data to report. If I'm wrong and someone who knows better reads this - please correct me!</p>
</blockquote>

<p></details>
<details>
<summary>Tell me about some different keyboard layouts and how MacOS distinguishes them</summary></p>

<blockquote>
<p>Three of the most popular physical keyboard layouts are the ANSI layout (common in the US), the ISO layout (common in Europe) and the JIS layout (common in Japan). They are similar but not identical. Here's a picture of these three physical layouts (plus a few more) courtesy of Wikipedia:</p>
</blockquote>

<p><center>
<img src="/img/2024-11-30-Fig3.png" alt="Fig 3" />
</center></p>

<blockquote>
<p>If you've used an external keyboard with your Macbook before, you may have seen a dialog box like this:</p>
</blockquote>

<p><center>
<img src="/img/2024-11-30-Fig4.png" alt="Fig 4" />
</center></p>

<blockquote>
<p>To identify the layout of your external keyboard, it asks you to press the key immediately to the right of your left-shift key, and then press the key immediately to the left of your right-shift key:</p>
</blockquote>

<p><center>
<img src="/img/2024-11-30-Fig5.png" alt="Fig 5" />
</center></p>

<blockquote>
<p>If you take another look at the keyboard layout diagram, you'll notice that the ISO layout has an extra key that the ANSI layout doesn't, just to the right of the left-shift key. (Its scan code is <code>0x56</code>.) The JIS layout, on the other hand, has an extra key that neither ANSI nor ISO has, just to the left of the right-shift key. (Its scan code is <code>0x73</code>.) </p>
<p>Hence, the OS can discriminate between a non-ISO and an ISO keyboard depending on whether the scancode from the key to the right of left-shift is <code>0x2c</code> (the Z key) or <code>0x56</code> respectively; and it can discriminate between a non-JIS and a JIS keyboard ddepending on whether the scancode from the key to the left of right-shift is <code>0x35</code> (usually the <code>?</code> key) or <code>0x56</code> respectively. This means these two keypresses are enough to determine your keyboard layout, at least if you assume these three are the only options, as my Macbook seems to do:</p>
</blockquote>

<p><center>
<img src="/img/2024-11-30-Fig6.png" alt="Fig 6" />
</center>
</details>
<hr></p>

<p><strong>(Scancode to HID message.)</strong> Keyboard scancodes are sent to the computer via an I/O bus. Scancodes aren't the only thing included in these messages: keyboards generally communicate with the operating system using the low-level <a href="https://en.wikipedia.org/wiki/Human_interface_device">HID (Human Interface Device) protocol</a>, which is the same protocol used for mice and other low-bandwidth computer peripherals. This protocol can be contrasted with the other protocols that exist for storage or audio/video devices, which generally require much quicker transfers of data in bulk. A <a href="https://en.wikipedia.org/wiki/Keyboard_controller_(computing)">keyboard controller</a> receives the HID messages and generates a <a href="https://en.wikipedia.org/wiki/Interrupt">hardware interrupt</a> so that the OS can process the message. Thus transcends your humble keypress the confines of a hardware keyboard, entering the wonderful world of software.</p>

<p><details>
<summary>Tell me more about the HID protocol</summary></p>

<blockquote>
<p>If you have a USB keyboard handy and <a href="https://www.wireshark.org">Wireshark</a> installed, you can actually inspect the HID packets yourself. According to the <a href="https://wiki.wireshark.org/CaptureSetup/USB">Wireshark Wiki</a>, you can perform packet captures on the USB interfaces of recent Macbooks (for me, these interfaces were called <code>XHC0</code> and <code>XHC1</code>). Unfortunately this requires disabling System Integrity Protection, so needless to say, I did not do any USB capturing on my main laptop. There's another app called <a href="https://desowin.org/usbpcap/">USBPcap</a> that purportedly allows you to accomplish something similar on Windows.</p>
<p>I captured myself plugging in my USB keyboard to a Macbook laptop and typing the text "hello world". You can download my PCAP file <a href="https://franklin.dyer.me/file/usb-keyboard.pcap">here</a> if you want to open it up for yourself in Wireshark. Here are a couple of interesting things I noticed:</p>
</blockquote>

<ul>
<li>At the beginning, my keyboard transmitted a bunch of metadata about itself, including its vendor and product ID and a string describing itself as <code>Dell USB Entry Keyboard</code>. Presumably this initial exchange is how my laptop discovered that it was a keyboard and not, say, a mouse or a thumb drive.</li>
<li>Among the metadata sent at the beginning is a language identifier for <code>English (United States)</code>. I'm unsure whether the self-reported language of the keyboard has any effect on how my laptop uses its input.</li>
<li>We can see a lot of packets being transmitted with no keypress data at all, and when there is a keypress, it lasts for a variable number of packets (sometimes 4, sometimes 5). This is because the keyboard controller polls the keyboard, rather than the keyboard generating interrupts. If applications receive discrete "key up" and "key down" events, it must be because the OS is discretizing this polling data into "up" and "down" events.</li>
<li>Data key presses are transmitted as scan codes in an array at the end of each HID message, but modifier key states are sent as bit flags. </li>
</ul>

<p></details>
<hr></p>

<p><strong>(HID message to kernel data.)</strong> Via the HID protocol, the OS has already identified your keyboard as a keyboard (and not a mouse, or a USB drive, etc) - so when it receives HID messages for keypress events, it knows to interpret them as keypresses. But keypresses are still described in HID messages as scancodes rather than character data. So the OS must translate each scancode by either producing a piece of character data (for data keys) or updating its internal representation of the modifier flags (for modifier keys).</p>

<p><details>
<summary>Tell me about Karabiner</summary></p>

<blockquote>
<p>Karabiner is a really cool open-source app for MacOS for  customizing the behavior of your keystrokes. It lets users customize  the behavior of their keyboard in ways that are not possible with a keyboard layout (see next section). For instance, I discovered Karabiner while looking for a way to create a keyboard shortcut to type two parentheses <em>and then</em> position the cursor between the two parentheses. (I often find myself typing open- and close-parens immediately followed by the left-arrow key to enter text between the parens. Some IDEs do this for you automatically, but I wanted to do this with a single keystroke in a plain text editor.)</p>
<p>Karabiner captures keyboard events at what is arguably the lowest possible level in userspace software: by using the <a href="https://developer.apple.com/documentation/iokit/iohidqueue_h"><code>IOHIDQueue</code> class</a> exposed by the MacOS <code>IOKit</code>. It registers a virtual keyboard with the OS and produces its own sequence of virtual keypress events, as if they were coming from an entirely different physical keyboard. The <a href="https://github.com/pqrs-org/Karabiner-Elements/blob/d2c62169e467ddfdc37c4ffc39c5099de511d85c/DEVELOPMENT.md?plain=1">development notes</a> for Karabiner are quite insightful and discuss a few interesting edge cases.</p>
</blockquote>

<p></details>
<hr></p>

<p><strong>(Kernel data to userspace data.)</strong> Having transformed keypress data from the keyboard into a more software-friendly form, the OS now decides what to do with it. On desktop systems, the event is usually transmitted to whichever application is "in the foreground". This is not the case for all keypress events, though. Consider the example of <code>Cmd+Tab</code> on MacOS. When this shortcut is enabled, it allows the user to cycle between running applications and quickly switch to a different foreground app, regardless of which app is currently in focus. (This is not to say that applications can't intercept <code>Cmd+Tab</code> at all - they can, but they won't receive the event by default.)</p>

<p><details>
<summary>Tell me more about keypress events on MacOS</summary></p>

<blockquote>
<p>MacOS Core Graphics uses the <a href="https://developer.apple.com/documentation/coregraphics/cgevent"><code>CGEvent</code> class</a> for representing low-level hardware events from peripherals, including both keypresses and mouse movements. It exposes an API for receiving and even manipulating keyboard input through something called an "event tap".</p>
<p>Here's a <a href="https://gist.github.com/franklindyer/49308a07f5bd79f01769cc16021e2cc1">simple Python script</a> I wrote using the PyObjC library that prints some information about each keypress on my Macbook, including the scan code, a Unicode string, the modifier flags, the ID of the originating keyboard, whether or not the event resulted from a key being held down, and the PID of the process receiving the keypress event. Note that this works even when the Terminal running the Python script is <em>not in focus</em>.</p>
<p>Not all apps on MacOS need such low-level access to keypress information. MacOS also exposes the <a href="https://developer.apple.com/documentation/appkit/nsevent"><code>NSEvent Class</code></a> for developers using its AppKit, which is more appropriate for applications that are not deliberately doing anything fancy with the keyboard.</p>
</blockquote>

<p></details>
<details>
<summary>Tell me more about keyboard layouts in MacOS</summary></p>

<blockquote>
<p>If you read the previous drop-down, you'll know that the keypress events that MacOS delivers to applications include a Unicode string. The Unicode string accompanying a keypress event does not have to correspond to the glyph printed on your keyboard in that position. The string included in each keypress event is determined by your <em>keyboard layout</em>.</p>
<p>You can configure your keyboard layout in MacOS (at the time of writing) by navigating to <code>System Preferences &gt; Keyboard &gt; Text Input &gt; Input Sources</code>. There are a number of preexisting keyboard layouts for world languages that you can select and add to your own "shortlist" of layouts that can be cycled through quickly. The OS is in charge of remembering which layout you have selected at any given time, and using it to decide what Unicode string add to each keypress event that it dispatches.</p>
<p>Because this is handled at the OS level, customizing key mappings isn't a total free-for-all. However, there is an API for writing your own keyboard layouts in the form of XML files. <a href="https://software.sil.org/ukelele/">Ukelele</a> is a handy piece of software that provides a user-friendly interface for designing your own keyboard layouts, but it's not too difficult to edit the XML by hand. MacOS requires a computer restart to make user-written keyboard layouts available, so presumably they are loaded up when the system starts.</p>
</blockquote>

<p></details>
<details>
<summary>Tell me how <code>Cmd+c</code> (copy to clipboard) and <code>Cmd+v</code> (paste from clipboard) are handled</summary></p>

<blockquote>
<p>There is nothing special about how <code>Cmd+c</code> and <code>Cmd+v</code> are handled at the level of the operating system, as far as I can tell. These key combos are hotkeys like any others, and it is up to each application whether to interpret them as "copy" and "paste" or as something else. They're just ubiquitous enough that most apps choose to use them in this way when possible.</p>
<p>On MacOS, the clipboard is simply a service that apps have access to through a specific API. Apparently AppKit exposes a class called <code>NSPasteboard</code> that any app can use to interact with a "pasteboard server" supporting certain actions that are enumerated in the <a href="https://developer.apple.com/documentation/appkit/nspasteboard"><code>NSPasteboard</code> API docs</a>. Clipboard contents can be more general than plain text data, and may include anything implementing the <a href="https://developer.apple.com/documentation/appkit/nspasteboardwriting"><code>NSPasteboardWriting</code></a> interface.</p>
</blockquote>

<p></details>
<hr></p>

<p><strong>(Userspace data to... something?)</strong> This is where it becomes impossible to give a general treatment of keyboard input, since different userspace applications can basically handle keypress events however they want. A text editor app may convert your characters into their ASCII or Unicode equivalents in its internal representation of a text file. A browser application usually captures <em>some</em> special hotkey combos and converts them into browser actions (e.g. <code>Cmd+T</code> for a new tab), but it delegates handling for most keypresses to individual websites by converting the keypresses into <code>keyUp</code> or <code>keyDown</code> events in Javascript. A text field may handle an <code>a</code> <code>keyDown</code> event into the character <code>'a'</code>, while a web-based platformer game using WASD controls may handle it by moving a player to the left.</p>

<p>Here we will specialize our treatment to a specific kind of application: <em>terminal emulators</em>, e.g. the <code>Terminal</code> app on MacOS.</p>

<hr>

<p><strong>(Userspace data to PTY master.)</strong> Terminal emulators use something called the <em>TTY system</em> to communicate with shells. This system is a bit of a relic, having originated with a specific kind of hardware in mind (i.e. a teletypewriter paired with a video terminal) that has long since been replaced by a software abstraction.</p>

<p>First a bit of terminology:</p>

<ul>
<li>the phrase <em>terminal</em> refers to a video terminal, once used to display information from a computer</li>
<li>the phrase <em>terminal emulator</em> refers to software that mimics the old-fashioned video terminal and teletypewriter pairing once commonly used to interface with a computer (e.g. <code>Terminal</code> or <code>xterm</code>)</li>
<li>the phrase <em>shell</em> refers to a program that is mainly used to issue commands, launch processes and navigate the filesystem (e.g. <code>bash</code> or <code>zsh</code>)</li>
<li>the phrase <em>TTY</em> or <em>TTY device</em> refers to a special kind of file that was once used to take input from a hardware teletypewriter but is now primarily used as a software abstraction</li>
<li>the phrase <em>PTY</em> (which stands for <em>pseudo-teletype</em>)  or <em>PTY device</em> refers to a special kind of file that mimics the hardware of a teletypewriter and the serial lines connecting it to a computer in software</li>
</ul>

<p>If that wasn't very clear, I recommend taking a look at <a href="http://www.linusakesson.net/programming/tty/">The TTY Demystified</a>, which explains the historical origins of TTY and PTY devices. </p>

<p>Before describing how a single character passes through the PTY system, let's briefly discuss what the terminal emulator needs to have done <em>beforehand</em>. Each "mock terminal session" is associated with a pseudoterminal master and pseudoterminal slave device, corresponding symbolically to the two ends of a physical wire that would join a teletypewriter to a computer (back when dinosaurs roamed the Earth). These devices are created by reading from <a href="https://www.man7.org/linux/man-pages/man4/pts.4.html"><code>/dev/ptmx</code>, the terminal multiplexor device</a>. The sequence of events looks something like this:</p>

<ul>
<li>terminal emulator (e.g. <code>Terminal</code>) opens</li>
<li>terminal emulator reads from <code>/dev/ptmx</code> and gets a master file descriptor <code>fdm</code></li>
<li>terminal emulator gets a slave file descriptor <code>fds</code> by calling <code>ptsname</code> on <code>fdm</code></li>
<li>terminal emulator calls <code>fork</code>, spawning a child process</li>
<li>child process closes <code>fds</code> and points <code>stdin</code>, <code>stdout</code> and <code>stderr</code> to <code>fds</code></li>
<li>child process executes a shell (e.g. <code>zsh</code>)</li>
</ul>

<p>This all needs to happen <em>before</em> we start typing things into the terminal emulator. Then, when it receives a keypress event from the OS, unless it's a hotkey specific to the terminal emulator, it just writes the character data to its master PTY file descriptor.</p>

<p></details>
<details>
<summary>Tell me how to use <code>/dev/ptmx</code> by hand</summary></p>

<blockquote>
<p>Have a look at <a href="https://gist.github.com/franklindyer/c9b1840342ab205be297e6d0c38483e1">this small C program</a>, which does nothing more than create a new TTY slave by opening <code>/dev/ptmx</code>, writing to it in a parent process and reading from it in a child process.</p>
</blockquote>

<p></details>
</details>
<details>
<summary>Tell me how special characters are sent</summary></p>

<blockquote>
<p>The shell <code>/bin/zsh</code> handles several special keystrokes that aren't interpreted as character data, such as the arrow keys, which are used to inspect the command history or move your cursor around within the command you're typing. But this must means that the arrow keys are somehow written to <code>/dev/ptmx</code> and read from some slave device <code>/dev/ttysXXX</code>, even though the arrow keys do not naturally correspond to any character. How does this work?</p>
<p>You can actually figure this out for yourself with a bit of trickery. By <em>reading directly</em> from the TTY slave device currently in use by a shell, we can intercept the bytes that the terminal emulator is sending our shell and dump them into a file, where we can inspect them. Try following these steps:</p>
</blockquote>

<ol>
<li>Open a <code>Terminal</code> window.</li>
<li>Run the command <code>tty</code>. This prints the name of the TTY slave device in use by the shell.</li>
<li>Open a new <code>Terminal</code> window.</li>
<li>In shell number two, execute <code>cat /dev/ttysXXX &gt; dump.txt</code>, where <code>/dev/ttysXXX</code> is the name you found in part 2.</li>
<li>Leave this running and go back to window number one.</li>
<li>Press each of the arrow keys several times.</li>
<li>Go back to window number two and halt the program with <code>Ctrl+c</code>.</li>
<li>Open the file <code>dump.txt</code> with a hex editor.</li>
</ol>

<blockquote>
<p>Your file probably looks something like this:</p>
</blockquote>

<div class="code">
<pre><code>
00000000: 1b5b 415b 415b 411b 5b41 5b41 5b41 5b41  .[A[A[A.[A[A[A[A
00000010: 5b41 1b5b 411b 5b41 5b41 5b41 1b5b 415b  [A.[A.[A[A[A.[A[
00000020: 415b 415b 415b 431b 5b43 5b43 431b 5b43  A[A[A[C.[C[CC.[C
00000030: 5b43 5b43 1b5b 435b 435b 431b 5b43 5b43  [C[C.[C[C[C.[C[C
00000040: 5b42 1b5b 425b 425b 421b 5b42 5b42 5b42  [B.[B[B[B.[B[B[B
00000050: 1b5b 425b 425b 421b 5b42 5b42 5b42 1b5b  .[B[B[B.[B[B[B.[
00000060: 445b 445b 441b 5b44 5b44 5b44 5b44 5b44  D[D[D.[D[D[D[D[D
00000070: 1b5b 445b 445b 445b 445b 445b 445b 44    .[D[D[D[D[D[D[D
</code></pre>
</div>

<blockquote>
<p>What you're seeing are the <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a>. These codes comprise a protocol that were once used by video terminals to communicate with processes, and are now used by terminal <em>emulators</em> like <code>Terminal</code>. ANSI escape codes are used for terminals to send special commands to shells that are not meant to be interpreted as character data, as well as a way for shells or other processes to send commands back to the terminal telling it how to alter its appearance. The escape codes for the up, right, down and left arrow keys respectively are <code>0x1b5b41</code>, <code>0x1b5b43</code>, <code>0x1b5b42</code> and <code>0x1b5b44</code>.</p>
<p>You might notice that in the above hex dump, these byte sequences are not always complete. For the up arrow, sometimes we see the full <code>0x1b5b41</code>, and sometimes we just see a <code>0x5b41</code>. This is because of a race condition: the shell and <code>cat</code> processes were performing concurrent reads of <code>/dev/ttysXXX</code>, and the escape sequences are multiple bytes long, meaning that there is a chance that the different bytes comprising a single escape sequence will be read by different processes.</p>
</blockquote>

<p></details>
<details>
<summary>Tell me how <code>Ctrl+c</code> is handled</summary></p>

<blockquote>
<p>You may be familiar with <code>Ctrl-c</code> as the key combination to press if you want to kill a process running in your terminal. How exactly does this work?</p>
<p>When you press this key combination, the terminal emulator writes <code>Ctrl-c</code> to the TTY master as usual. However, the way this data is handled at the <em>kernel</em> level is different. Rather than making this data readable as bytes from the slave TTY, the TTY subsystem takes this as an indication that it should send a <code>SIGINT</code> signal to the foreground process in the shell's process group.</p>
<p>The default behavior for handling the <code>SIGINT</code> signal is to exit. This is why, if you press <code>Ctrl+c</code> while a program you've launched from the terminal is running, it will usually exit. However, the way this signal is handled is actually up to each process. You can write a simple program in C with a custom <code>SIGINT</code> handler that does nothing when it receives this signal, and therefore does not respond to <code>Ctrl+C</code>.</p>
<p>You can also use <code>stty</code> to change this behavior in the kernel, so that <code>Ctrl+C</code> is carried to the slave TTY as data and another key is translated into an interrupt signal. For instance, running <code>stty intr k</code> will give <code>k</code> this special role. This is just one of the many TTY configuration options that the operating system API offers (a couple more are discussed in the next section).</p>
<p><a href="https://jvns.ca/blog/2024/10/31/ascii-control-characters/">Julia Evans</a> has had some fun categorizing all of the different terminal control characters like <code>Ctrl+C</code> - check out her post!</p>
</blockquote>

<p></details>
<details>
<summary>Tell me how <code>ssh</code> (the Secure SHell) fits into this picture</summary></p>

<blockquote>
<p>For simplicity's sake, I'm only talking here about the command-line application <code>ssh</code>. SSH also is the name of a more general protocol that can be used with different frontend clients, e.g. <a href="https://www.putty.org">PuTTY</a> for Windows.</p>
<p>First of all, <code>ssh</code> is a bit of a misnomer. It is not a shell at all, because it is not the parent process that spawns child processes based on the commands you type in. SSH is more like a relay that uses network connectivity to connect a terminal emulator on one host with a shell running on a completely different host.</p>
<p>OSs commonly come with an SSH daemon such as <code>sshd</code> installed, which is usually configured to listen persistently to port <code>22</code> (by default). When you initiate a connection, your client machine makes a series of requests to port <code>22</code> of the remote host, where the daemon must be listening to receive it. Assuming this is successful, the daemon authenticates you using a public-private key pair or password.</p>
<p>After this, you can use the shell on the remote machine in a more or less seamless way, as if you had a terminal directly plugged into the remote machine. This illusion works so well because the terminal emulator is local while the shell is remote. As for how this fits into the TTY system: the SSH client on your local host reads from the local TTY slave device, and the SSH daemon on the remote hots spins up its own master-slave TTY device pair while processing your request, with the daemon using the master end and the shell using the slave end. Each character you type undergoes the following journey:</p>
</blockquote>

<ul>
<li>the local terminal emulator writes it to its <code>/dev/ptmx</code> file descriptor</li>
<li><code>ssh</code> (client) reads the character from its TTY slave file</li>
<li><code>ssh</code> (client) creates an encrypted payload containing the character using the server's pubkey</li>
<li><code>ssh</code> (client) sends the payload using the TCP protocol, which generally requires <a href="https://blog.hyfather.com/blog/2013/04/18/ssh-uses-four-tcp-segments-for-each-character/">four segments</a></li>
<li><code>sshd</code> (server) receives the payload and decrypts it using its private key</li>
<li><code>sshd</code> (server) writes the character to its <code>/dev/ptmx</code> file descriptor</li>
<li>the remote shell reads the character from its TTY slave file</li>
</ul>

<blockquote>
<p>Here's a revised version of my original diagram that depicts the situation when you use SSH:</p>
</blockquote>

<p><center>
<img src="/img/2024-11-30-Fig2.png" alt="Fig 2" />
</center></p>

<blockquote>
<p>But hey, don't take my word for it. You can check a lot of this yourself using basic command-line utilities. Here's what I did to sanity-check my own understanding:</p>
</blockquote>

<ol>
<li>Open <code>Terminal</code> and use <code>ssh</code> to connect to a remote server.</li>
<li>Open a new <code>Terminal</code> tab.</li>
<li>Run <code>ps -a | grep ssh</code> to find the PID of the process running your SSH connection.</li>
<li>Run <code>lsof -p &lt;pid&gt;</code> to see the list of open file descriptors for that process.</li>
<li>You should see that <code>stdin</code> (file descriptor <code>0</code>) is a TTY slave device. For my, <code>stderr</code> (file descriptor <code>2</code>) was the same TTY slave, and <code>stdout</code> (file descriptor <code>1</code>) was set to <code>/dev/null</code>.</li>
<li>Now switch back to the <code>Terminal</code> window with your remote SSH shell.</li>
<li>Run <code>pstree -p | grep sshd</code>. You should see at least one <code>sshd</code> process with a shell as its child process. Grab  both of their PIDs.</li>
<li>Run <code>lsof -p &lt;sshd-pid&gt;</code>. (You may need <code>sudo</code>.) You should see <code>/dev/ptmx</code> among its open files.</li>
<li>Finally, run <code>lsof -p &lt;shell-pid&gt;</code>. You should see a TTY slave device open for all three of <code>stdin</code>, <code>stdout</code> and <code>stderr</code>.</li>
<li>Exit.</li>
</ol>

<p></details>
<hr></p>

<p><strong>(PTY master to PTY slave.)</strong> You might think that character data written to the master device can be read out from the slave device straightaway, like a pipe. But that's not quite right. The TTY subsystem offers a multitude of configurable settings regulating how characters are delivered to the slave end and mapping certain characters onto special actions. These settings are configurable through an API accessible to the child process.</p>

<p><details>
<summary>Tell me about the line buffer</summary></p>

<blockquote>
<p>Among the configuration options provided by the TTY subsystem is the <em>line buffer</em>. By default, character input from the TTY master end is entered into a buffer, which is flushed with each newline character <code>\n</code>. This means that not only does the shell not execute any command until you enter a newline, but it <em>can't even access your characters</em> until you enter a newline.</p>
<p>The <code>termios</code> API allows a program to put its TTY device in "raw mode", which disables the line buffer and makes input available one character at a time. You can read more about it <a href="https://www.man7.org/linux/man-pages/man3/termios.3.html">here</a>. Note that shells often have their TTYs set to <em>raw mode</em> because a custom line buffer is the kind of convenience feature that would fall under a shell's purview. For instance, this allows shells to do things like allow you to browse your command history with the up- and down-arrow keys, which would not immediately be delivered to the shell in "cooked" mode.</p>
</blockquote>

<p></details>
<details>
<summary>Tell me why I can see my characters right away even when lines are buffered</summary></p>

<blockquote>
<p>The TTY mode is "cooked" rather than raw by default. So, for example, if you write a simple C program that reads input character by character from <code>stdin</code>, and launch it from a shell, due to line buffering it will not receive any characters until the first newline is entered. However, you will still see the characters you type appear in your terminal as you type them.</p>
<p>This has to do with another option offered by the TTY system: <em>input echoing</em>. With echoing turned on (which is the case by default), any characters written to the master TTY will also appear in the master TTY output, not just the slave TTY output. Hence, the terminal emulator reads back the same characters it had just written to the master TTY file, as if the slave process had printed those characters to <code>stdout</code> - even though the slave may not have received those characters at all yet.</p>
</blockquote>

<p></details>
<hr></p>

<p><strong>(PTY slave to char.)</strong> This can go either to the shell itself, or to a process that has been spawned from the shell. When you launch a process from a shell, it inherits the shell's <code>stdin</code>, <code>stdout</code> and <code>stderr</code> file descriptors. The shell and its child process both have the PTY slave device open while the child process is running, but the shell (normally) just waits for its child to finish and doesn't read from the PTY slave concurrently. Either way, <code>char</code>s are read from the PTY slave file using the <code>read</code> system call, as with any other file.</p>

<p><details>
<summary>Tell me what happens when multiple processes read from the PTY slave concurrently</summary></p>

<blockquote>
<p>What happens is a race condition! Just like when multiple processes try reading from the same end of a pipe concurrently, some bytes may be read by one process while others are read by the other process. As for which bytes go to which process, it's not deterministic.</p>
<p>Try it out for yourself:</p>
</blockquote>

<ol>
<li>Open a new <code>Terminal</code> window.</li>
<li>Run <code>tty</code> to see the TTY slave device name.</li>
<li>Open a new <code>Terminal</code> window.</li>
<li>Run <code>cat /dev/ttysXXX</code>, using the name from part (2).</li>
<li>Go back to your original terminal window.</li>
<li>Try typing something. You should find that only about half of the characters show up.</li>
<li>Go back to the second terminal window.</li>
<li>You should see all of the characters that were "lost" in part (6).</li>
</ol>

<p></details>
<hr></p>

<p><strong>(Char to PTY slave.)</strong> What the process does with the characters it receives simply depends on what kind of process it is. If it is a shell, it probably checks if the line entered is one of a few different built-in shell commands (of the flavor of <code>cd</code> or <code>clear</code>) or a binary executable found from some directory in the system <code>PATH</code> variable. If it is another process, it could do any number of things with its character input.</p>

<p>Whichever process is reading from the slave PTY, let us suppose that it produces some text output. As mentioned earlier, when the shell spawns a child process, its <code>stdin</code>, <code>stdout</code> and <code>stderr</code> file descriptors all point to the open PTY slave device by default. So unless the child process' output is being redirected to a file or piped to yet another process, it will be written right back to the PTY slave device.</p>

<p><details>
<summary>Tell me how fancy CLIs like <code>vim</code> or <code>tmux</code> completely change the appearance of my terminal</summary></p>

<blockquote>
<p>Just as the terminal emulator uses <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a> to transmit special characters to the child process reading from the TTY slave, that child can also use ANSI escape codes to send messages back to the terminal emulator. Many of the ANSI escape codes correspond not to special characters, but to actions that configure and manipulate the terminal's appearance.</p>
<p>These include special control sequences for moving the terminal cursor to the beginning or end of a line or even to a certan row and column position $(m,n)$ in the terminal's fixed-width text grid. There are also control sequences for changing the text color and background color of characters displayed in the terminal, and for hiding or showing the cursor in the terminal. A lot of these codes are documented in the <a href="https://vt100.net/docs/vt220-rm/contents.html">VT220 Programmer Reference Manual</a> which is chock-full of interesting little tidbits.</p>
<p>One of my favorites is the infamous "bell character": running <code>echo '\a'</code> in a shell from your terminal emulator of choice will probably cause it to make a "boop" sound. When you run this, a process running <code>echo</code> writes the bell character <code>\a</code> (which is <code>0x07</code> in ASCII) to the TTY slave device, the terminal emulator reads this character from the TTY master device, and produces a sound effect.</p>
<p>If you're curious about the control characters that your favorite CLI program uses, the <code>tee</code> command can help you investigate by duplicating all of that program's raw output to a text file. For instance, if you want to investigate the control code used to draw <code>vim</code>'s slick text-based UI, try running <code>vim hello.txt | tee dump.txt</code>. Proceed to write some stuff in the file <code>hello.txt</code> and quit, and then open up <code>dump.txt</code> (preferably in a hex viewer like <code>xxd</code>). You should see every character that appeared on the screen while <code>vim</code> was open, including graphical characters used to draw the UI, and a bunch of control sequences.</p>
</blockquote>

<p></details>
<hr></p>

<p><strong>(PTY slave to PTY master.)</strong> Any characters written to the PTY slave device get shuttled back to the PTY master end, where the process that opened <code>/dev/ptmx</code> in the first place (the terminal emulator) can read them from its file descriptor. Note that although there may be other open file descriptors for <code>/dev/ptmx</code>, each one can only read characters written to the specific PTY slave that was created as a result of its opening. This is a big difference between PTY devices and pipes: many different processes may have the same file <code>/dev/ptmx</code> opened but read completely different character streams from it. That is to say: the OS discriminates between the different open file descriptors for <code>/dev/ptmx</code>, even though they correspond to the same open file.</p>

<hr>

<p><strong>(PTY master to glyph.)</strong> Finally, the terminal emulator reads characters from the TTY master and, when they are not part of a control sequence, displays them on the emulated terminal screen. It uses the fonts that are present on your system to decide how to draw each character. (You can find out exactly which font files your terminal emulator has open by finding out the PID of its running process and using <code>lsof -p | grep Font</code>.) On MacOS, these are usually <code>.ttf</code> or TrueType files. <a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/">TrueType</a> is a complicated beast, but in essence it provides for each glyph to be described as a sequence of <a href="https://en.wikipedia.org/wiki/BÃ©zier_curve">Bezier Curves</a>.</p>

<hr>

<p>As for how the glyphs are displayed in a <code>Terminal</code> window, how the MacOS <code>WindowServer</code> manages the different overlapping application windows on your desktop, and how all of this graphical information is aggregated and mapped onto the pixels of your computer screen - that's a story for another day. It doesn't have enough to do with characters inherently to be on-topic for this post.</p>

<p>Cheers!</p>

    <br>
<a href="/">go to homepage</a>
<hr>
<div id="license-statement">The posts on this website are licensed under <a href="https://creativecommons.org/licenses/by-nc/4.0/">CC-by-NC 4.0</a>.</div>
<div id="notbyai"><a href="https://notbyai.fyi/"><img src="/img/written-by-human.png"/><img src="/img/illustrated-by-human.png"/></a></div>
</body>
</html>
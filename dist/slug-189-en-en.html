<html>
<head>
    <title>Algebra and arithmetic with inductive types</title>
    <link rel="stylesheet" type="text/css" href="/css/style.css" />
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      processEscapes: true,
      menuSettings: { inTabOrder: false },
      "AssistiveMML": {
         disabled: false,
         styles: {
            ".MJX_Assistive_MathML": {
                position:"absolute!important",
                clip: (MathJax.Hub.Browser.isMSIE && (document.documentMode||0) < 8 ?
                    "rect(1px 1px 1px 1px)" : "rect(1px, 1px, 1px, 1px)"),
                padding: "1px 0 0 0!important",
                border: "0!important",
                height: "1px!important",
                width: "1px!important",
                overflow: "hidden!important",
                display:"block!important"
            }
        }
      }
    });
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, type=text/html" charset="UTF-8">
    <link rel="stylesheet" href="/css/style.css">
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
</head>
<body>
    <h3>Algebra and arithmetic with inductive types</h3>

<p>As I mentioned in my previous blog post, lately I've spent a lot of time learning about category theory and type theory. One of the biggest application areas of type theory is with computer-aided proofs and proof assistants. I've found that axiomatizing the natural number system (and other more exotic number systems) in proof assistants like Agda and attempting to prove simple arithmetic identities has made me more aware of how easy it is to skip steps while doing algebraic proofs.</p>

<p>NOTE: a little bit of experience with Haskell or some other functional programming language would be helpful for reading this blog post.</p>

<h4>Examples of inductive types <a id="toc-section-1" class="toc-section"></a></h4>

<p>First, a bit of conceptual scaffolding before we get into the weeds with Agda. (If you are familiar with the basics of type theory already, feel free to skip this, or skim it as a refresher.) I won't give a full explanation of the basics of type theory here, but I'll informally introduce some concepts that are necessary to understand the motivation behind certain quirks of Agda. If you want to learn about type theory in more depth, check out <a href="https://homotopytypetheory.org">the HoTT book</a>, which I've been working through lately. </p>

<p>In type theory, the most basic concept is that of a <strong>type</strong>, which, intuitively speaking, is roughly analogous to a <em>set</em>. Types in type theory are, to some extent, meant to formalize the notion of a type as it appears in computer science and programming languages, such as the types <code>int</code> and <code>char</code> in C or the types <code>Bool</code> and <code>String</code> in Haskell. However, unlike sets, it is helpful to think of types not as completed collections of things that already exist, but rather as constraints/delimitations of things which could <em>potentially</em> exist, but which may or may not be "instantiated" yet. As such, types are often defined by their <strong>constructors</strong>, which are rules that allow you to produce elements or <strong>inhabitants</strong> of that type. If $a$ is an inhabitant of the type $A$, we write $a:A$, which is roughly analogous to the expression $a\in A$ in set theory. (By the way, types that are defined in terms of constructors this way are called <strong>inductive types</strong>.)</p>

<p>Briefly, let's consider a few examples. The familiar type of the natural numbers $\mathbb N$ can be defined by two constructors: an element $0 : \mathbb N$, and a function $\mathsf{S}:\mathbb N\to \mathbb N$, called the <em>successor function</em>. Starting with the element $0$, we can produce additional elements of $\mathbb N$ by repeatedly applying the constructor $\mathsf S$ to form $\mathsf{S}0, \mathsf{SS}0$, and so on. In Haskell, we could define this type as follows:</p>

<div class="code"><code><pre>
data Nat = Zero | Succ Nat
</pre></code></div>

<p>and we shall shortly see what the analogous definition in Agda looks like. For a more novel example, we could also define a type $\mathsf{BTree}$ with constructors $\text{Leaf}:\mathsf{BTree}$ and $\text{Fork}:\mathsf{BTree}\to \mathsf{BTree} \to \mathsf{BTree}$. In other words, these constructors tell us that there is an inhabitant of $\mathsf{BTree}$ called $\text{Leaf}$, and given any two inhabitants of $\mathsf{BTree}$, we can construct from them a new inhabitant of $\mathsf{BTree}$. In Haskell:</p>

<div class="code"><code><pre>
data BTree = Leaf | Fork BTree BTree
</pre></code></div>

<p>How does this abstract definition in terms of constructors have anything to do with binary trees? Here's a graphical way of interpreting it: there is, of course, a trivial binary tree consisting of nothing but a leaf, and any more complex binary tree can be thought of as a combination of two binary trees, with one to the left of the root and the other to the right of the root.</p>

<p><center><img src="/img/2022-06-02-Fig1.png" alt="Fig 1" /></center></p>

<p>A much simpler example of an inductive type is the type denoted $\mathbf{2}$, which is called the <strong>binary type</strong>. It is inductively defined by the constructors $0:\mathbf{2}$ and $1:\mathbf{2}$. The elements $0$ and $1$ are the <em>only</em> inhabitants of the type $\mathbf{2}$, since there are no other constructors for this type. The binary inductive type can also double as an alias for $\mathsf{Bool}$, the type of truth-values, with $0$ representing falsity and $1$ representing truth. In Haskell, we have</p>

<div class="code"><code><pre>
data BinaryType = Zero | One
</pre></code></div>

<p>We also have a <strong>unary type</strong> denoted $\mathbf{1}$, which has only one constructor $\star:\mathbf{1}$. That is, the type $\mathbf{1}$ has a unique element. There is a <strong>nullary type</strong> $\mathbf{0}$ as well, which has no constructors at all, meaning that it is <strong>uninhabited</strong>. In other words, there is <em>no way to construct any instance of the type</em> $\mathbf{0}$.</p>

<p>Finally, there are a few different ways of defining new types from existent ones. First of all, given the types $A$ and $B$, we can form the <strong>function type</strong> $A\to B$, which is the type of <em>functions</em> from $A$ to $B$. To construct elements of the type $A\to B$, it suffices to define a function $f:A\to B$ using an explicit formula or a <a href="https://en.wikipedia.org/wiki/Lambda_calculus#Definition">lambda expression</a>. If $A$ is an inductive type, this can be accomplished using <strong>pattern matching</strong>, by defining the value of $f$ at every possible argument casewise depending on which constructor was used to form the argument. For instance, in Haskell, we can define a function of type $\mathsf{BTree}\to\mathsf{Int}$ like this, which counts the number of leaves of a binary tree:</p>

<div class="code"><code><pre>
numLeaves :: BTree -> Int
numLeaves Leaf = 1
numLeaves (Fork t1 t2) = (numLeaves t1) + (numLeaves t2)
</pre></code></div>

<p>We can also form the <strong>product type</strong> $A\times B$, whose analogue in set theory is the <em>Cartesian product</em>  of $A$ and $B$, consisting of tuples $(a,b)$ where $a:A$ and $b:B$. The product type $A\times B$ can be  thought of as having a constructor $(-,-):A\to B\to A\times B$: that is, given an element of type $A$ and one of type $B$, we construct an element of type $A\times B$. We also have the <strong>coproduct type</strong> $A+B$, whose set-theoretic analogue is the <em>disjoint union</em>. Each element of $A+B$ corresponds to either an element of $A$ or an element of $B$, so that $A+B$ can be defined by two constructors: $\text{inl}:A\to A+B$ and $\text{inr}:B\to A+B$. There are also some more techniques of type-forming, but I won't go into them here - you can read about the <strong>dependent function type</strong> and the <strong>dependent sum type</strong> in the HoTT book, if you want. (We will see examples of these in Agda later, but I won't comment on them explicitly.)</p>

<h4>Types as propositions <a id="toc-section-2" class="toc-section"></a></h4>

<p>The analogy between type theory and set theory breaks down when it comes to the type-theoretic treatment of logic. In set theory, logical statements about sets are sequences of characters such as $\land$ "and", $\lor$ "or", $\forall$ "for all", $\exists$ "there exists", "\in" "is an element of", etc. which follow certain syntactic rules, but which, more importantly, are <em>external</em> to the system of set theory itself. Syntax and semantics are separate, and making meta-theoretic statements about set theory is very difficult: it requires us to encode the logical language in set theory itself.</p>

<p>Type theory, on the other hand, does not use the language of first-order logic to state theorems about type theory. In type theory, <em>types</em> lead a double life: they can be interpreted as set-like collections of (potential) instances, <em>or</em> as propositions! Specifically, the type $A$ can be interpreted as a kind of "collection", or it can be interpreted as the proposition which states "there exists something of type $A$". An element $a:A$, then, also doubles as either a member of the collection $A$, or as <em>evidence</em> that $A$ is a true proposition, or that there does indeed exist something of type $A$. According to this interpretation, types with elements represent true propositions, whereas empty (or <strong>uninhabited</strong>) types represent false propositions. For instance, the type $\mathbf{0}$ can be thought of as the proposition "false".</p>

<p>Of course, we would still like to be able to represent familiar logical concepts such as "and", "or", "not", and "implies" in our new logical language. These logical operations all have equivalents in type theory. If $A$ and $B$ are types representing propositions $P$ and $Q$, the proposition $P\land Q$ "$P$ and $Q$" is represented by the type $A\times B$. Why is this an appropriate analogy? Well, to construct an element of $A\times B$, we must supply an element $a:A$ <em>and</em> $b:B$, which allows us to build $\text{pair}(a,b):A\times B$, and this means that both $A$ and $B$ must be inhabited by $a:A$ and $b:B$, so that $P\land Q$ is true.</p>

<p>What about $P\lor Q$ "$P$ or $Q$"? This proposition is represented by the coproduct type $A+B$, for to instantiate an element of $A+B$, we must use one of the constructors $\text{inl}$ or $\text{inr}$. To use $\text{inl}:A\to A+B$, we must supply an element $a:A$, and to use $\text{inr}:B\to A+B$, we must supply an element $b:B$. Thus, in order for $A+B$ to inhabited, we must have either $A$ <em>or</em> $B$ be inhabited, hence the parallel with the proposition $P\lor Q$.</p>

<p>Now, what about $P\implies Q$ "$P$ implies $Q$"? This is analogous to the function type $A\to B$. Given an inhabitant $a:A$, a function $f:A\to B$ allows us to construct an inhabitant $b=f(a):B$, meaning that if $A$ is inhabited, $B$ must also be inhabited, so that if $P$ is true, $Q$ must also be true.</p>

<p>Finally, what is the type-theoretic equivalent of the proposition $\neg P$ "not P"? This one is trickier and a little less intuitive. But notice that, in propositional logic, the proposition $\neg P$ is equivalent to the proposition $P\implies \text{F}$, or "$P$ implies false". And we already know that the type-theoretic equivalent of $P\implies Q$ is the function type $A\to B$, and the equivalent of "false" is the nullary type $\mathbf{0}$. Hence, $\neg P$ can be represented by the type $A\to \mathbf{0}$. In other words, the proposition $P$ is false if an element of $A$ could be used to produce an element of the nullary type $\mathbf{0}$, which is impossible by definition.</p>

<p>It can be a fun exercise to try and reformulate well-known tautologies from propositional logic into type-theory language, and then <em>prove</em> them. And how does one prove propositions in type theory? By supplying an element of the corresponding type!</p>

<p>For instance, consider the tautology $P\implies P$. In type theory, the corresponding proposition for a given type $A$ would be the function $A\to A$. To define a function of this type, we must come up with a way of constructing an element of type $A$, given an element of type $A$. But this is trivial: was may simply use the identity function. As a lambda function this would be <script type="math/tex; mode=display">(\lambda x . x):A\to A</script> and we can also write this in Haskell as a polymorphic function: </p>

<div class="code"><code><pre>
id :: a -> a
id x = x
</pre></code></div>

<p>As a less trivial example, consider the tautology $P\implies \neg\neg P$. The type corresponding to this proposition would be $A\to ((A\to \mathbf{0})\to \mathbf{0})$. To define a function of this type would require us to construct an element of type $\mathbf{0}$ given elements of type $A$ and $A\to \mathbf{0}$. But if we are given $a:A$ and $f:A\to\mathbf{0}$, we may evaluate $f$ at $a$ to obtain $f(a):\mathbf{0}$! Hence, we have <script type="math/tex; mode=display">(\lambda x. \lambda f. f(x)) : A\to ((A\to\mathbf{0})\to\mathbf{0})</script> which proves the proposition.</p>

<p>As an interesting aside, the converse of the above tautology, the <strong>law of double negation</strong> $\neg\neg P\to P$, stating that every proposition that is not-not-true is necessarily true, is <em>not provable</em> in type theory. The type corresponding to this proposition is $((A\to \mathbf{0})\to\mathbf{0})\to A$, and if you want to convince yourself that you can't define a function of this type, try writing a polymorphic function <code>doubNeg :: ((a -&gt; b) -&gt; b) -&gt; a</code> in Haskell. This discrepancy between classical logic is what makes type-theoretic logic a kind of <strong>intuitionistic logic</strong>. (Another notable unprovable statement in type theory is the <strong>law of excluded middle</strong> $P\lor \neg P$.) Interestingly, however, we <em>can</em> eliminate a double negation from a triple negation, i.e. we can prove that $\neg\neg\neg P\to \neg P$ in type theory - this is a good exercise to try for yourself.</p>

<h4>Reasoning about equality <a id="toc-section-3" class="toc-section"></a></h4>

<p>There is one more piece to the puzzle that we need before we start doing algebraic proofs in Agda using type theory. We have seen how propositional logic is paralleled in type theory, but most of the statements that we wish to prove when doing arithmetic or algebra take the form $X=Y$ for some expressions $X$ and $Y$. We have not yet seen how to express <em>statements of equality</em> in type theory. But since all propositions are represented by types, statements of equality should as well: hence, for any type $A$ and any elements $x,y:A$, there is an <strong>equality type</strong> denoted $(x =_A y)$, which represents the proposition "$x$ and $y$ are equal as elements of $A$.</p>

<p>For me, understanding the equality type has been (and still is) one of the most confusing parts of basic type theory. However, for this post, there are only a few things that we need to know about it. For any type $A$ with inhabitant $a:A$, we can construct an element $\text{refl}_a:(a=_A a)$, i.e. we can assert that each element of $A$ is equal to itself, the <em>reflexive</em> property of equality. Additionally, for any element $p:(a =_A b)$, which we often call a <strong>path</strong> from $a$ to $b$, we can <em>invert</em> it to form a path $p^{-1}:(b =_A a)$, expressing the <em>symmetric</em> property of equality. (More generally, there is a polymorphic function $-^{-1}:(a=_A b)\to (b =_A a)$ for inverting paths.) Finally, given two paths $p:(a =_A b)$ and $q: (b =_A c)$, we can <em>concatenate</em> them to form a path $p\cdot q: (a =_A c)$, expressing the <em>transitive</em> property of equality. (There is also a polymorphic function $-\cdot -:(a =_A b)\to (b =_A c)\to (a =_A c)$.) Finally, there is a polymorphic function called $\text{ap}$ which is used to apply functions to both sides of an equality, which has the following type-signature: <script type="math/tex; mode=display">\text{ap}:(f:A\to B)\to (a =_A b)\to (f(a) =_B f(b))</script> so that the partially-applied function $\text{ap}_f$ has signature <script type="math/tex; mode=display">\text{ap}_f: (a =_A b)\to (f(a) =_B f(b))</script> allowing us to conclude that if $a=b$ as elements of $A$, and if $f:A\to B$ is a function, then $f(a)=f(b)$ as elements of $B$. These are the tools that we will need to accomplish what we want in Agda.</p>

<p>I said that I wouldn't get into the nuts and bolts of the equality type in this blog post, but here's a teaser: the equality types are actually <em>inductive types</em> as well! To define a polymorphic function over the types $(a =_A b)$ with $a,b$ ranging over the type $A$, the inductive definition of the equality type states that it suffices to define the function on all values $\text{refl}_a:(a =_A a)$, in the same way that to define a function on $\mathsf{Nat}$, it suffices to specify how it behaves on elements taking the forms $0$ and $\mathsf{S}n$. By the inductive definition of the equality type, the <em>symmetric</em> and <em>transitive</em> properties of equality are not axioms - they can be derived from the definition!</p>

<p>One more note before we start getting into some algebra. It might seem strangely trivial to speak of equality types $(a=_A b)$ - if $a$ and $b$ are unequal, then the type is empty, and if they are equal, the type is inhabited. What's the big deal? Well, in type theory, a great distinction is drawn between <em>definitional equality</em> and plain old equality. When we consider an equality type of the form $(a =_A b)$ in which $a$ and $b$ are defined by more complex expressions, they may indeed be equal, but not <em>definitionally</em> equal, so that some manipulation is required to show that they represent the same element of $A$. For instance, in $\mathsf{Nat}$, if $a$ is defined as $a:=\mathsf{SSSS}0$ and $b$ is defined as $b:= (\mathsf{SS}0)\times (\mathsf{SS}0)$, we will need to custom-write a function $\text{twoEq}:(\mathsf{SSSS}0 =_\mathsf{Nat} (\mathsf{SS}0)\times (\mathsf{SS}0))$ to exhibit their equality. (This is precisely the kind of manipulation that we will do in Agda.) On the other hand, if $a,b$ are literally <em>defined</em> in the same way, we can inhabit the equality type $(a =_A b)$ by simply using the reflexivity element $\text{refl}_a$ or $\text{refl}_b$.</p>

<p>Suppose that we wished to show that $\mathsf{SSSS}0=(\mathsf{SS}0)\times (\mathsf{SS}0)$, i.e. to produce an element of the identity type $(\mathsf{SSSS}0=_{\mathsf{Nat}}(\mathsf{SS}0)\times (\mathsf{SS}0))$, and that over the course of our previous manipulations, we had already procured elements of the following identity types: <script type="math/tex; mode=display">p:(\mathsf{SSSS}0=_{\mathsf{Nat}}\mathsf{SSS}0+\mathsf{S}0)</script>
<script type="math/tex; mode=display">q:(\mathsf{SSS}0=_{\mathsf{Nat}}\mathsf{SS}0+\mathsf{S}0)</script>
<script type="math/tex; mode=display">r:((\mathsf{SS}0)\times (\mathsf{SS}0) =_{\mathsf{Nat}} (\mathsf{SS}0+\mathsf{S}0)+\mathsf{S}0)</script> Then we can cleverly construct an element of the desired equality type $(\mathsf{SSSS}0=_{\mathsf{Nat}}(\mathsf{SS}0)\times (\mathsf{SS}0))$ using symmetricity, transitivity, and function application as follows: <script type="math/tex; mode=display">p\cdot \text{ap} _{-+\mathsf{S}0}(q)\cdot r^{-1}</script> This construction can be visualized using the following diagram:</p>

<p><center><img src="/img/2022-06-02-Fig2.png" alt="Fig 2" /></center></p>

<p>Calling elements of the equality type "paths" is more than just an unusual choice of terminology. It is often intuitively helpful to think of elements of $(a =_A b)$ as paths, even as paths of some <em>topological space</em>. This is the intuitive basis for the connection between topology/homotopy theory and type theory, hence the name "homotopy type theory" (often abbreviated HoTT). The analogy goes much deeper than the suggestive picture I've sketched above - but I won't go any further down this rabbit hole for now. If you'd like to learn some more about homotopy theory, you can take a look at <a href="https://franklin.dyer.me/post/144">this old blog post</a>, in which I introduce the fundamental group of topological spaces.</p>

<h4>Getting started with Agda <a id="toc-section-4" class="toc-section"></a></h4>

<p>If you want to follow along with the rest of the post and play with code on your own, now's the time to install Agda. There are lots of instructions online for how to install Agda on various platforms - my laptop uses MacOS, so I used Homebrew to install Agda. You should install both <code>agda</code>, which will allow you to compile Agda code, and <code>agda-mode</code>, a plugin for the Emacs text-editor that incorporates a lot of keyboard shortcuts for typing math symbols in emacs. Most people who use Agda use this plugin and have strange unicode symbols strewn throughout their code, so if you want to build on anyone else's Agda code, this plugin is a must-have. (Unless you want to copy-paste all of the symbols into your text file - yuck!) Once you have this plugin installed, you can use <a href="https://people.inf.elte.hu/divip/AgdaTutorial/Symbols.html">this handy reference page</a> to look up the shortcuts for various mathematical symbols. And, of course, if you're not used to using Emacs, there are plenty of resources online for familiarizing yourself with it. I personally use Vim for most things, so it's been a bit of a learning curve for me!</p>

<p>Now, just a few more preliminaries. Navigate to your home directory and create a directory <code>~/.agda</code>. First, you should clone the <a href="https://github.com/agda/agda-stdlib">Agda Standard Library</a> into this directory. Then you'll have to create two configuration files, called <code>defaults</code> and <code>libraries</code>. In <code>defaults</code>, add one line containing the text <code>standard-library</code>.  In <code>libraries</code>, add a line containing the absolute path to the file <code>standard-library.agda-lib</code>, which is contained in the <code>agda-stdlib</code> repository that you should have already cloned.</p>

<p>Wherever you please, create a directory called <code>agda-projects</code> or something similar, which will contain all of the Agda files that you write. Now, there are two files that you need to download into this directory, which are necessary for defining and proving some basic properties of the equality type. (You don't need to read or understand these files for the sake of this blog post, but if you're interested, they are mostly stolen from <a href="https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#contents">this fantastic tutorial</a> on implementing HoTT in Agda.) The first file is <a href="https://franklin.dyer.me/file/Universes.agda">Universes.agda</a>, and the second is <a href="https://franklin.dyer.me/file/EqualityBase.agda">EqualityBase.agda</a>.</p>

<p>Before you start writing your own Agda code that makes use of these two, you will need to compile them. <code>EqualityBase</code> is dependent on <code>Universes</code>, so you need to compile the latter first. Open <code>Universes.agda</code> in Emacs with agda-mode enables, then press <code>Ctrl-C Ctrl-l</code> to compile the code. (It should say "all done" at the bottom of the editor.) Then open <code>EqualityBase.agda</code> and do the same. For future reference, <code>Ctrl-C Ctrl-l</code> is the shortcut that you should use later on to compile your Agda code after making changes.</p>

<p>Now open a new file called whatever you want (mine is called <code>blog_arithmetic.agda</code>) and add two lines to the beginning like this:</p>

<div class="code"><code><pre>
module blog_arithmetic where
    open import EqualityBase public
</pre></code></div>

<p>...replacing <code>blog_arithmetic</code> with whatever the title of your file is (they must match, or you'll get an error). Now we're ready to start writing Agda code! For future reference, remember to indent all of your code inside of the <code>module</code> statement.</p>

<h4>Natural arithmetic in Agda <a id="toc-section-5" class="toc-section"></a></h4>

<p>It happens that the natural number type $\mathbb N$ is already defined in <code>EqualityBase.agda</code>, but we're going to define our own natural numbers from scratch for illustrative purposes. Here's the syntax for implementing the inductive definition of $\mathsf{Nat}$ in Agda, as we formulated it earlier:</p>

<div class="code"><code><pre>
data Nat : 𝓤₀ ̇ where
  zero : Nat 
  succ : Nat → Nat
</pre></code></div>

<p>By the way: if you're wondering about the character sequence used to type <code>𝓤₀ ̇</code>, it's <code>\MCU\_0 \^.</code> (This tripped me up the first time I tried to write it - I couldn't figure out that there was a space between the zero and the dot.) If you're curious about what this actually is, it's essentially our <em>universe of discourse</em>, i.e. the higher-order type in which any other types we define will reside. The shortcut for typing the arrow <code>→</code> is <code>\-&gt;</code>.</p>

<p>Now let's define addition and multiplication. Because the function symbols <code>+</code> and <code>‌×</code> are already being used in <code>EqualityBase</code>, we will use different symbols for the infix operations of addition and multiplication, namely <code>⊞</code> and <code>⊠</code> respectively. We can define them in much the same way as we would recursively define addition and multiplication in Haskell, using pattern matching:</p>

<div class="code"><code><pre>
_⊞_ : Nat → Nat → Nat
zero ⊞ n     = n
(succ m) ⊞ n = succ (m ⊞ n)   

_⊠_ : Nat → Nat → Nat
zero     ⊠ n = zero
(succ m) ⊠ n = (m ⊠ n) ⊞ n   

infixl 20 _⊞_
infixl 21 _⊠_
</pre></code></div>

<p>The presence of underscores on both sides of <code>⊞</code> and <code>⊠</code> in their respective definitions indicates that they are infix operations. The two lines at the end indicate that the operation <code>⊠</code> has a higher precedence than <code>⊞</code>, syntactically formalizing our desired order of operations.</p>

<p>As an example of what proofs look like in Agda, here's a simple example, proving that $n+0=n$ for all $n:\mathsf{Nat}$. Although this may seem trivial, the equality $n+0=n$ is not <em>definitional</em> - we defined addition such that $0+n=n$ for all $n:\mathsf{Nat}$ (the base case of our recursive definition above), but it is not defined such that $n+0=n$. And we haven't yet proven that addition is commutative, so we can't conclude that $n+0=0+n=n$. Be careful what you take for granted! </p>

<div class="code"><code><pre>
pluszero : (n : Nat) → (n ⊞ zero) ≡ n
pluszero zero = refl zero
pluszero (succ n) = ap succ (pluszero n)
</pre></code></div>

<p>So what's going on here? By the definition of $\mathsf{Nat}$, given a natural number $n:\mathsf{Nat}$, we may assume that it is either equal to $0$ or the successor of some natural number. Thus, we may define <code>pluszero</code> using pattern-matching with two cases: <code>pluszero zero</code> and <code>pluszero (succ n)</code>. If $n=0$, the proof is trivial, because <code>zero ⊞ zero</code> is <em>definitionally</em> equal to <code>zero</code> by the recursive definition of <code>⊞</code>, so we may simply return <code>refl zero</code>. On the other hand, if the argument takes the form <code>succ n</code>, we can recursively call <code>pluszero n</code> in our definition of <code>pluszero (succ n)</code>. Since <code>pluszero n</code> yields an assertion of the form <code>(n ⊞ zero) ≡ n</code>, we may use <code>ap succ</code> to apply the <code>succ</code> function to both sides of this equality, obtaining <code>succ (n ⊞ zero) ≡ succ n</code>. This is not quite what we want, since the desired type of <code>pluszero (succ n)</code> is <code>((succ n) ⊞ zero) ≡ succ n</code>. However, notice that the types <code>succ (n ⊞ zero) ≡ succ n</code> and <code>((succ n) ⊞ zero) ≡ succ n</code> are <em>definitionally equal</em>, since <code>(succ m) ⊞ n = succ (m ⊞ n)</code> is part of the definition of <code>⊞</code>. Agda is capable of identifying these two definitionally equal types, so we may simply return <code>ap succ (pluszero n)</code> for the value of <code>pluszero (succ n)</code>.</p>

<p>Here's a way of visualizing what is going on here, in a similar vein to the picture from before:</p>

<p><center><img src="/img/2022-06-02-Fig3.png" alt="Fig 3" /></center></p>

<p>I'm using blue lines to represent definitional equalities. We start with a definitional equality between $0$ and $0+0$, then carry it over to an equality between $\mathsf{S}0$ and $\mathsf{S}(0+0)$ using $\text{ap} _\mathsf{S}$, and make use of the fact that $\mathsf{S}(0+0):= \mathsf{S}0+0$ definitionally (which Agda does automatically). Then we apply $\text{ap}_\mathsf{S}$ again and repeat the process. Note that, although we can never generate <em>all of</em> the equalities $n+0=n$ (since there are infinitely many natural numbers), the function <code>pluszero</code> allows us to generate proofs of these equalities <em>on demand</em>.</p>

<p>Now that you've seen what an example proof looks like, I'd encourage you to take a crack at proving some other simple arithmetic identity in Agda using these definitions. Try proving that addition is commutative or that multiplication distributes over addition, or perhaps something like $(n+1)(n+1)=n^2+2n+1$. You might be surprised at how often you get stuck, or how many intermediate lemmas you need! Once you've had enough, keep reading and we'll prove a couple of useful lemmas.</p>

<p>Let's prove three more propositions: firstly, that $\mathsf{S}n=n+1$ for all $n:\mathsf{Nat}$; secondly, that $m+(n+p)=(m+n)+p$ for all $m,n,p:\mathsf{Nat}$ (i.e. associativity of addition); and thirdly, that $\mathsf{S}(m+n)=m+\mathsf{S}n$ for all $m,n:\mathsf{Nat}$. These proofs will be much the same as the previous proof:</p>

<div class="code"><code><pre>
one : Nat
one = succ zero   

succ+1 : (n : Nat) → succ n ≡ (n ⊞ one)
succ+1 zero     = refl one 
succ+1 (succ n) = ap succ (succ+1 n)  

plus-assoc : (m n p : Nat) → (m ⊞ (n ⊞ p)) ≡ (m ⊞ n ⊞ p)
plus-assoc zero n p = refl (n ⊞ p)
plus-assoc (succ m) n p = ap succ (plus-assoc m n p)  

m-plus-Sn : (m n : Nat) → (m ⊞ succ n) ≡ succ (m ⊞ n)
m-plus-Sn zero n     = refl (succ n)
m-plus-Sn (succ m) n = ap succ (m-plus-Sn m n)
</pre></code></div>

<p>Notice that in order to formulate the former proposition, we had to first define <code>one</code>. However, we could have equivalently chosen to phrase <code>succ+1</code> as having the type <code>(n : Nat) → succ n ≡ (n ⊞ (succ zero))</code>, but we're using the alias <code>one = succ zero</code> for the sake of conciseness.</p>

<p>Proving commutativity of addition - i.e. that $m+n=n+m$ for all $m,n:\mathsf{Nat}$ - will not be so straightforward. As before, we'll want to prove it inductively by making use of pattern matching on the first argument, so that our final proof will look something like </p>

<div class="code"><code><pre>
plus-comm : (m n : Nat) → (m ⊞ n) ≡ (n ⊞ m)
plus-comm zero n     = ???
plus-comm (succ m) n = ???
</pre></code></div>

<p>The base case isn't too tricky - it reduces to showing that $0+n=n+0$, and we've already shown that $n+0=n$ for all $n:\mathsf{Nat}$ with our function <code>pluszero</code>. This is definitionally equivalent to $n+0=0+n$, which is <em>almost</em> the equality we want, but backwards. This is where we'll have to use the <em>path inversion</em> operation that I mentioned in an earlier section:</p>

<div class="code"><code><pre>
plus-comm : (m n : Nat) → (m ⊞ n) ≡ (n ⊞ m)
plus-comm zero n     = (pluszero n) ⁻¹
plus-comm (succ m) n = ???
</pre></code></div>

<p>Now for <code>plus-comm (succ m) n</code>. To define this recursively, it suffices to obtain an element of type <code>((succ m) ⊞ n) ≡ (n ⊞ (succ m))</code> from <code>plus-comm m n</code>, an element of type <code>(m ⊞ n) ≡ (n ⊞ m)</code>. Given that $m+n=n+m$, we can apply $\mathsf{S}$ to both sides to obtain $\mathsf{S}(m+n)=\mathsf{S}(n+m)$, which is definitionally equivalent to $\mathsf{S}m+n=\mathsf{S}(n+m)$. Additionally, we have just proven in a previous lemma that $n+\mathsf{S}m=\mathsf{S}(n+m)$. Hence, we can chain the equalities <script type="math/tex; mode=display">\mathsf{S}m+n=\mathsf{S}(n+m)</script> and <script type="math/tex; mode=display">n+\mathsf{S}m=\mathsf{S}(n+m)</script> together using transitivity to obtain the desired equality <script type="math/tex; mode=display">\mathsf{S}m+n=n+\mathsf{S}m</script> ...but how can we write this all in Agda? Well, the given element of $\mathsf{S}m+n=_{\mathsf{Nat}}\mathsf{S}(n+m)$ is <code>ap succ (plus-comm m n)</code>, and the given element of $\mathsf{S}(n+m)=_\mathsf{Nat} n+\mathsf{S}m$ is <code>(m-plus-Sn n m) ⁻¹</code>, so we can concatenate these two paths to obtain <code>(ap succ (plus-comm m n)) ∙ ((m-plus-Sn n m) ⁻¹)</code> of type $\mathsf{S}m+n=_{\mathsf{Nat}}n+\mathsf{S}m$. Now we're ready to finish our code:</p>

<div class="code"><code><pre>
plus-comm : (m n : Nat) → (m ⊞ n) ≡ (n ⊞ m)
plus-comm zero n     = (pluszero n) ⁻¹
plus-comm (succ m) n = (ap succ (plus-comm m n)) ∙ ((m-plus-Sn n m) ⁻¹)
</pre></code></div>

<p>This compiles in Agda! Hooray!</p>

<p>There are plenty more things to prove about natural arithmetic in Agda, such as basic things like commutativity and associativity of multiplication and the left- and right-distributivity of multiplication over addition, or more interesting facts like the following summation identity: <script type="math/tex; mode=display">1+3+\cdots + (2n-1)=n^2</script> Another interesting puzzle is to prove more complex equalities involving associativity using only <code>plus-assoc</code>. For instance, as a (somewhat tedious) exercise, you might try proving that <script type="math/tex; mode=display">(((m+n)+q)+r)+s = m+(n+(q+(r+s)))</script> using only a direct definition involving <code>plus-assoc</code>, with no induction/pattern-matching. You might be surprised at how many steps it can take to rearrange the order of additions in expressions involving as few as just $4$ additions! (For a graphical representation of this puzzle, have a look at the <a href="https://en.wikipedia.org/wiki/Associahedron">associahedron</a>.)</p>

<p>If you want to continue playing with natural number arithmetic by building off of the code that I've written here, but don't want to copy-paste all of it by hand, you can download <a href="https://franklin.dyer.me/file/blog_arithmetic.agda">blog_arithmetic.agda here</a>.</p>

<h4>Ordinal arithmetic in Agda <a id="toc-section-6" class="toc-section"></a></h4>

<p>Before wrapping up, let's take a brief look at a more "exotic" number system implemented in Agda. I'd like to create a custom type for the <a href="https://en.wikipedia.org/wiki/Ordinal_number">ordinal numbers</a> below $\omega^\omega$, with their operations of addition and multiplication. If you aren't familiar with the ordinal numbers, in short, they represent <em>order types</em>, which you can read about in <a href="https://franklin.dyer.me/post/171">this previous blog post</a>. The ordinal numbers have analogues of the natural numbers $1,2,3,$ and so on, which represent finite totally-ordered sets. The ordinal $\omega$, however, represents the order type of the natural numbers. We can define an addition operation on order types which consists of "concatenating" two order types together, and a multiplication operation, which consists of substituting the elements of one order with copies of another. (You can read about both of these operations in the blog post linked above.)</p>

<p>Unfortunately, there's no hope for implementing a data type that allows us to construct <em>all</em> ordinals, since there are uncountable ordinals (and even the countable ones <a href="http://www.madore.org/%7Edavid/math/ordinal-zoo.pdf">can get pretty crazy</a>), but I'll show how to implement the ordinals below $\omega^\omega$: that is, the ordinals that can be represented as polynomials in $\omega$, such as $\omega^4\cdot 3 + \omega\cdot 5 + 1$. Just as every natural number can be uniquely represented by a sequence of successor operations applied to $0$, every ordinal of this form can be represented uniquely by a sequence of successor operations and multiplications by $\omega$ applied to $1$. For instance, <script type="math/tex; mode=display">\omega^4\cdot 3 + \omega\cdot 5 + 1=\mathsf{S}(\omega\times \mathsf{SSSSS}(\omega\times\omega\times\omega\times 1))</script> Hence, we can represent these ordinals using an inductive type called <code>ωpoly</code> with one starting element <code>one : ωpoly</code> and two unary constructing functions <code>_+1 : ωpoly → ωpoly</code> and <code>ω×_ : ωpoly → ωpoly</code>. My definition for <code>ωpoly</code> is as follows:</p>

<div class="code"><code><pre>
data ωpoly : 𝓤₀ ̇ where
    one : ωpoly
    _+1 : ωpoly → ωpoly
    ω×_ : ωpoly → ωpoly
</pre></code></div>

<p>Defining addition and multiplication for ordinals of this form is a little trickier than with the natural numbers, since there are more cases to consider: when pattern matching, an arbitrary element of <code>ωpoly</code> could take any one of the three forms <code>one</code>, <code>m +1</code>, and <code>ω× m</code>. Here's the definition that I came up with for addition:</p>

<div class="code"><code><pre>
_⊞_ : ωpoly → ωpoly → ωpoly
m      ⊞ one    = m +1
m      ⊞ (n +1) = (m ⊞ n) +1
one    ⊞ (ω× n) = ω× n
(m +1) ⊞ (ω× n) = m ⊞ (ω× n)
(ω× m) ⊞ (ω× n) = ω× (m ⊞ n)
</pre></code></div>

<p>The third and fourth cases are motivated by the fact that the ordinal $\omega$ <em>absorbs</em> addition with $1$ on the left. That is, concatenating a single element at the beginning of the order type of $\mathbb N$ leaves the order type the same. The fifth case states intuitively that $m$ copies of $\omega$ followed by $n$ copies of $\omega$ is the same as $(m+n)$ copies of $\omega$.</p>

<p>Here's my definition of multiplication for ordinals:</p>

<div class="code"><code><pre>
_⊠_ : ωpoly → ωpoly → ωpoly
(ω× m) ⊠ n      = ω× (m ⊠ n)
m      ⊠ one    = m
m      ⊠ (n +1) = (m ⊠ n) ⊞ m
one    ⊠ (ω× n) = ω× n
(m +1) ⊠ (ω× n) = m ⊠ (ω× n)
</pre></code></div>

<p>I've managed to prove that under these definitions, ordinal addition is associative, and I'm currently working on a proof that multiplication is left-distributive over addition. An interesting fact, however, is that it is <em>not</em> right-distributive over addition. Nor are addition and multiplication commutative! So ordinal arithmetic is quite different from arithmetic with the natural numbers. Nevertheless, there are plenty of interesting algebraic identities to be proven, such as the following (courtesy of Sierpinski): <script type="math/tex; mode=display">(\omega^3+\omega)^5 = (\omega^5+\omega^3)^3</script> and the following (which comes from my own generalization of Sierpinski's exercise): <script type="math/tex; mode=display">(\omega^{201}+\omega^{102})^{100}=(\omega^{100}+\omega)^{201}</script> As of right now, my goal is to build up the theory of ordinal arithmetic on $\omega^\omega$ in Agda to a sufficient extent that I'm able to prove Sierpinski's identity $(\omega^3+\omega)^5 = (\omega^5+\omega^3)^3$. Perhaps this will be the subject of a future post!</p>

<h4>Summary <a id="toc-section-7" class="toc-section"></a></h4>

<p>Initially, I had wanted to write a short post exploring several different systems of arithmetic in Agda. However, once I started writing, it occurred to me that there are a lot of formal and conceptual prerequisites for motivating and understanding the style of Agda, so it ended up turning into an intuitive introduction to type theory and getting set up with Agda instead. Now that I've written this up, maybe I'll be able to get deeper into the weeds in future posts.</p>

<p>As an aside, this summer I'll be a counselor and mentor at <a href="https://promys.org">PROMYS</a>, a summer program for highschoolers at Boston University that introduces formal/rigorous proofs and several topics in number theory and abstract algebra. I actually attended this program as a highschooler, and benefitted greatly from all of the new ideas that I was exposed to there. Part of what the program encourages students to do is prove what they know about arithmetic and $\mathbb N$ "from the ground up", starting with a collection of axioms and taking nothing else for granted, no matter how "obvious" it may seem. As I work with my high-school mentees at PROMYS, it might be fun to try and follow along by proving some of the same results about number theory and abstract algebra in Agda! This would certainly be in keeping with the idea of being explicit about our assumptions and proving everything else from the ground up.</p>

    <br>
<a href="/">go to homepage</a>
<hr>
<div id="license-statement">The posts on this website are licensed under <a href="https://creativecommons.org/licenses/by-nc/4.0/">CC-by-NC 4.0</a>.</div>
<div id="notbyai"><a href="https://notbyai.fyi/"><img src="/img/written-by-human.png"/><img src="/img/illustrated-by-human.png"/></a></div>
</body>
</html>